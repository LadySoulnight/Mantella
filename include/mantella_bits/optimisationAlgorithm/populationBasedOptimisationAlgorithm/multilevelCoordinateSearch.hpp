namespace mant {

  template <typename ParameterType>
  class MultilevelCoordinateSearch : public PopulationBasedOptimisationAlgorithm<ParameterType> {
  public:
    //initialPointIndex is the index inside initialPopulation_ which is used as the starting point.
    explicit MultilevelCoordinateSearch(const std::shared_ptr<OptimisationProblem<double>> optimisationProblem, const unsigned int& populationSize) noexcept;
    MultilevelCoordinateSearch(const MultilevelCoordinateSearch&) = delete;
    MultilevelCoordinateSearch& operator=(const MultilevelCoordinateSearch&) = delete;

    //If local search is enabled, this sets the algorithm to be used. By default, HillClimbing is used.
    void setLocalSearch(const std::shared_ptr<TrajectoryBasedOptimisationAlgorithm<ParameterType>> localSearch);

    //sets the maximum amount of splits (or depth of splitting) for the original box.
    //\nDefault is 5 * numberOfDimensions + 10.
    void setBoxDivisions(const unsigned int divisions);

    //sets the maximal number of iterations the local search is running (each time it is called). 
    //If set to 0, local search will be skipped completely. \nDefault is 50.
    void setMaximumLocalSearchSteps(const unsigned int steps);

    std::string to_string() const noexcept override;
  protected:
    void optimiseImplementation() override;

    //
    // Variables
    //
    // <editor-fold>

    std::shared_ptr<TrajectoryBasedOptimisationAlgorithm<ParameterType>> localSearch_;

    //TODO: could be moved to constructor as a definable variable
    unsigned int step1_ = 1000; //initial size of some vectors/matrices for which the initial sizing depends on input
    unsigned int step_ = 200; //we have more boxes than our vectors/matrices can hold, they are increased by this amount.
    unsigned int dim_ = 1000; //the current size of the vectors matrices

    //smax: \n
    //maximum number of box divisions
    unsigned int boxDivisions_;

    //u,v: \n
    //with u=col(0) and v=col(1)
    arma::Mat<double> boundaries_;

    //local
    unsigned int maxLocalSearchSteps_;

    //if it is split in the initialization procedure: -(splitting index) of box m \n
    //otherwise: splitting index of box m \n
    //accessed by matlab-1, values are matlab
    arma::Col<int> isplit_;

    //levels of the boxes (level(j) = 0 if box j has already been split) \n
    //accessed by matlab-1, values are matlab
    arma::Col<unsigned int> level_;

    //label (number) of the parent of box m
    //accessed by matlab-1, values are matlab
    arma::Col<unsigned int> ipar_;

    // if box m was generated by splitting according to the initialization list 
    //(in the initialization procedure or later): -(number which child box m is) \n
    //otherwise: number which child box m is \n
    //accessed by matlab-1, values are matlab
    arma::Col<int> ichild_;

    //f: has two rows:\n
    //first row contains function value at the base vertex of box m.\n
    //second row contains function value at the splitting point of box m (if z(1,m) ~= Inf)
    arma::Mat<double> boxBaseVertexFunctionValues_; //f

    //has two rows:\n
    //first row contains value of the isplit(m)th coordinate of the base vertex of box m. \n
    //second row contains k if box m is split according to the initialization list and initListValues_(:,k) 
    //contains the function values obtained by splitting the box. Otherwise its splitting value of box m
    arma::Mat<double> z_;

    //0 if box is eligible for splitting by expected value (default. \n
    //1 if box has been determined as not eligible.
    arma::Col<unsigned int> nogain_;

    //l
    arma::Col<unsigned int> initialPointIndex_;

    //initilization list
    arma::Mat<double> x0_;

    //f0
    arma::Mat<double> initListValues_;

    //istar
    arma::Col<unsigned int> bestPointIndex_;

    //x
    arma::Col<double> baseVertex_;

    //v1
    arma::Col<double> originalOppositeVertex_;

    //y
    arma::Col<double> oppositeVertex_;

    //record(i) points to the best non-split box at level i. \n
    //accessed by matlab-1, values are matlab
    arma::Col<unsigned int> record_;

    //counter for boxes not in the 'shopping basket'
    unsigned int nboxes_ = 1;

    //counter for boxes in the 'shopping basket'
    unsigned int nbasket_ = 0;

    //auxiliary counter
    unsigned int nbasket0_ = 0;
    unsigned int m_;

    //counter of points that have been used as starting points for a local search
    unsigned int nloc_ = 0;

    //columns are the points that have been used as starting points for local search
    arma::Mat<double> xloc_;

    arma::Col<unsigned int> variabilityRanking_; //p, accessed by matlab-1, values are matlab-1

    //xmin: \n
    //matrix with n rows; the columns are the points in the shopping basket' (i.e. good points resp. local minimizers)
    arma::Mat<double> pointsInBasket_;

    //fmi: \n
    //function values corresponding to the 'shopping basket'; fmi(i) is the function value at xmin(:,i)
    arma::Col<double> pointsInBasketValue_;
    // </editor-fold>

    //TODO: All methods need to be checked if &parameters are necessary there or if they can be replaced in some form.

    //init.m
    //computes function values for the initialpoint and for the final best point of the initial list
    void initialPointSetup();

    //initbox.m \n
    //generates the boxes in the initialization procedure.
    // For each coordinate i we compute the quadratic interpolant to any
    // three consecutive (x0(i,j),f0(j,i)). xl and xu are the minimum and
    // maximum of the quadratic interpolant, respectively. If x0(i,istar(i)) 
    // belongs to two boxes, the one containing the minimizer of the 
    // quadratic model in coordinate i is taken as the current box for the
    // next coordinate. All boxes generated in the initialization procedure
    // get the level of their parent box increased by one.
    void initBoxes() noexcept;

    //genbox.m \n
    //generates a box with parent box # ipar = par, level = level, ichild 
    // = nchild and boxBaseVertexFunctionValue = baseVertexFunctionValue
    void genBox(int nbox, int par, int level, int nchild, double baseVertexFunctionValue) noexcept;

    //polint.m \n
    //the interpolating polynomial is given by
    //p(x) = d(1) + d(2)(x - x(1)) + d(3)(x - x(1))(x - x(2))
    // with x = supportPoints, f = functionValues
    arma::Col<double> quadraticPolynomialInterpolation(arma::Col<double> supportPoints, arma::Col<double> functionValues) const noexcept;

    //quadmin.m \n
    //computes the minimum x of the quadratic polynomial
    //p(x) = d(1) + d(2)(x - x0(1)) + d(3)(x - x0(1))(x - x0(2)) in the interval [a,b]
    double minimumQuadraticPolynomial(double a, double b, arma::Col<double> d, arma::Mat<double> x0_fragment) const noexcept;

    //quadpol.m \n
    //evaluates the quadratic polynomial
    //p(x) = d(1) + d(2)(x - x0(1)) + d(3)(x - x0(1))(x - x0(2)) at x
    double quadraticPolynomial(double x, arma::Col<double> d, arma::Mat<double> x0_fragment) const noexcept;

    //split1.m \n
    //splits the interval [x1,x2] according to the golden section rule
    double splitByGoldenSectionRule(double x1, double x2, double f1, double f2) const noexcept;

    //splrnk.m \n
    //determines the splitting index and splitting value for splitting a box by rank
    void splitByRank(unsigned int par, unsigned int numberOfDimensions, arma::Col<unsigned int> n0) noexcept;

    //split2.m \n
    //determines a value x1 for splitting the interval [min(x,y),max(x,y)] 
    //is modeled on the function subint with safeguards for infinite y
    double splitBySubint(double x, double y) const noexcept;

    //splinit.m \n
    //splits box # par at level s according to the initialization list in the 
    //ith coordinate and inserts its children and their parameters in the list.
    //returns isFinished() || isTerminated()
    bool splitByInitList(unsigned int splittingIndex, unsigned int minimalLevel, unsigned int par) noexcept;

    //split.m \n
    //splits box # par at level s in its ith coordinate into two or three 
    //children and inserts its children and their parameters in the list
    //returns isFinished() || isTerminated()
    bool split(unsigned int splittingIndex, unsigned int minimalLevel, unsigned int par) noexcept;

    //exgain.m \n
    //determines the splitting index, the splitting value and the expected 
    //gain vector e for (potentially) splitting a box by expected gain
    arma::Col<double> expectedGainOfSplit(unsigned int par, unsigned int numberOfDimensions, arma::Col<unsigned int> n0, arma::Col<double> x1, arma::Col<double> x2, arma::Col<double> f1, arma::Col<double> f2) noexcept;

    //strtsw.m \n
    //updates the record list for starting a new sweep and computes the
    //lowest level containing non-split boxes
    unsigned int startSweep() noexcept;

    //vertex.m \n
    //computes the base vertex x and the opposite vertex y of the box # j 
    //of MCS and the 'neighboring vertices' x1 and x2 and their function
    //values f1 and f2 needed for separable quadratic interpolation
    void vertex(unsigned int par, arma::Col<double>& x1, arma::Col<double>& x2, arma::Col<double>& f1, arma::Col<double>& f2, arma::Col<unsigned int>& n0) noexcept;

    //vert1.m
    void vert1(int updateIndex, unsigned int j, unsigned int m, arma::Col<double>& x, arma::Col<double>& x1, arma::Col<double>& x2, arma::Col<double>& f1, arma::Col<double>& f2) noexcept;

    //vert2.m
    void vert2(int updateIndex, unsigned int j, unsigned int m, arma::Col<double> x, arma::Col<double>& x1, arma::Col<double>& x2, arma::Col<double>& f1, arma::Col<double>& f2) noexcept;

    //vert3.m
    void vert3(int updateIndex, unsigned int j, const int& f0columnIndex, arma::Col<double>& x1, arma::Col<double>& x2, arma::Col<double>& f1, arma::Col<double>& f2) noexcept;

    //updtf.m \n
    //If we leave the i-coordinate x(i) of the base vertex of a box by
    //going back to the base vertices of its ancestors, we have to 
    //generate 'fictitious' function values by assuming a separable model
    //for all coordinates i1 ~= i for which coordinate and function values
    //have not yet been found
    void updtf(unsigned int numberOfDimensions, unsigned int splittingIndex, double fold, arma::Col<double> x1, arma::Col<double> x2, arma::Col<double>& f1, arma::Col<double>& f2, double baseVertexValueCurrentBox) noexcept;

    //subint.m \n
    //computes for real x and real or infinite y two points x1 and x2 in 
    //[min(x,y),max(x,y)] that are neither too close nor too far away from x
    arma::Col<double> subint(double x, double y) const noexcept;

    //updtrec.m \n
    //updates the pointer record(s) to the best non-split box at level s.
    //f=vector containing the base vertex function values of the already defined boxes
    void updateRecord(unsigned int label, int level, arma::Col<double> f) noexcept;

    //chkloc.m \n
    //checks whether a point has already been used as starting point for a local search
    bool checkLocationNotUsed(arma::Col<double> location) const noexcept;

    //addloc.m \n
    //adds a new point to the list of starting points for local search
    void addLocation(arma::Col<double>& loc) noexcept;

    //basket.m \n
    //checks whether a candidate for local search lies in the 'domain of 
    //attraction' of a point in the 'shopping basket'
    bool pointInsideDomainOfAttraction(arma::Col<double>& loc, std::shared_ptr<double> valueAtLoc, double nbasket) noexcept;

    //basket1.m \n
    //checks whether a candidate for local search lies in the 'domain of 
    //attraction' of a point in the 'shopping basket'
    bool candidateInsideDomainOfAttraction(arma::Col<double> candidate, double valueAtCandidate, double nbasket) noexcept;
  };

  //
  // Implementation
  //
  // <editor-fold>

  template <typename ParameterType>
  MultilevelCoordinateSearch<ParameterType>::MultilevelCoordinateSearch(const std::shared_ptr<OptimisationProblem<double>> optimisationProblem,
      const unsigned int& populationSize) noexcept
  : PopulationBasedOptimisationAlgorithm<ParameterType>(optimisationProblem, populationSize) {
    //for convenience
    const unsigned int numberOfDimensions = optimisationProblem->numberOfDimensions_;

    this->bestParameter_ = arma::Col<double>(numberOfDimensions, arma::fill::zeros);

    std::shared_ptr<TrajectoryBasedOptimisationAlgorithm<ParameterType >> localsearch(new HillClimbing<ParameterType>(optimisationProblem));

    setLocalSearch(localsearch);
    setBoxDivisions(5 * numberOfDimensions + 10);
    setMaximumLocalSearchSteps(50);

    boundaries_ = arma::join_rows(optimisationProblem->getLowerBounds(), optimisationProblem->getUpperBounds());

    //init of large arrays
    isplit_ = arma::Col<int>(step1_, arma::fill::zeros);
    level_ = arma::Col<unsigned int>(step1_, arma::fill::zeros);
    ipar_ = arma::Col<unsigned int>(step1_, arma::fill::zeros);
    ichild_ = arma::Col<int>(step1_, arma::fill::zeros);
    boxBaseVertexFunctionValues_ = arma::Mat<double>(2, step1_, arma::fill::zeros);
    z_ = arma::Mat<double>(2, step1_, arma::fill::zeros);
    nogain_ = arma::Col<unsigned int>(step1_, arma::fill::zeros);

    //initialization list
    x0_ = arma::Mat<double>(numberOfDimensions, 3);
    x0_.col(0) = boundaries_.col(0);
    x0_.col(1) = (boundaries_.col(0) + boundaries_.col(1)) / 2.0;
    x0_.col(2) = boundaries_.col(1);
    initListValues_ = arma::Mat<double>(this->populationSize_, step1_); //need to do large allocation cause matlab code expands automatically later
    bestPointIndex_ = arma::Col<unsigned int>(numberOfDimensions);
    variabilityRanking_ = arma::Col<unsigned int>(numberOfDimensions);

    //init of record list, nboxes, nbasket,nbasket0, m, nloc, xloc
    //values not listed here are defined in header
    record_ = arma::Col<unsigned int>(boxDivisions_ - 1, arma::fill::zeros);
    m_ = numberOfDimensions;
    record_(0) = 1;
    xloc_ = arma::Mat<double>(numberOfDimensions, step1_);
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::optimiseImplementation() {
    //for convenience
    const unsigned int numberOfDimensions = this->optimisationProblem_->numberOfDimensions_;
    
    initialPointSetup();

    this->bestParameter_ = arma::Col<double>(numberOfDimensions, arma::fill::zeros);
    //generate boxes
    initBoxes();


    //TODO: find better value than step1_...
    pointsInBasket_ = arma::Mat<double>(numberOfDimensions, step1_); //xmin
    pointsInBasketValue_ = arma::Col<double>(step1_); //fmi

    // s - value is matlab - the vector record is updated, and the minimal level s containing non-split boxes is computed
    unsigned int minimalLevel = startSweep();

    while (!this->isFinished() && !this->isTerminated() && minimalLevel < boxDivisions_) {
      unsigned int par = record_(minimalLevel - 1) - 1; //the best box at level s is the current box

      arma::Col<double> x1 = arma::Col<double>(numberOfDimensions);
      x1.fill(arma::datum::inf);
      arma::Col<double> x2 = arma::Col<double>(numberOfDimensions);
      x2.fill(arma::datum::inf);
      arma::Col<double> f1 = arma::Col<double>(numberOfDimensions, arma::fill::zeros);
      arma::Col<double> f2 = arma::Col<double>(numberOfDimensions, arma::fill::zeros);
      arma::Col<unsigned int> n0 = arma::Col<unsigned int>(numberOfDimensions, arma::fill::zeros);
      vertex(par, x1, x2, f1, f2, n0);

      bool doSplit = false; //splt
      if (minimalLevel > 2 * numberOfDimensions * (arma::min(n0) + 1)) {
        splitByRank(par, numberOfDimensions, n0);
        doSplit = true;
      } else {
        //TODO: this if should be unnecessary in c++. else be !if
        if (nogain_(par)) {
          doSplit = false;
        } else {
          arma::Col<double> expectedGain = expectedGainOfSplit(par, numberOfDimensions, n0, x1, x2, f1, f2); //e

          //index again so use 0, matlab=1
          double fexp = boxBaseVertexFunctionValues_(0, par) + arma::min(expectedGain);
          if (fexp < this->bestObjectiveValue_) {
            doSplit = true;
          } else {
            doSplit = false;
            nogain_(par) = 1;
          }
        }
      }
      if (doSplit) {
        int i = isplit_(par) - 1;
        level_(par) = 0;
        if (z_(1, par) == arma::datum::inf) {
          m_++;
          z_(1, par) = m_;
          if (splitByInitList(i, minimalLevel, par)) {
            break; //should break out of major while loop
          }
        } else {
          z_(0, par) = baseVertex_(i);
          if (split(i, minimalLevel, par)) {
            break;
          }
        }
        //if the pre-assigned size of the `large' arrays has already been exceeded, these arrays are made larger
        //first if is custom to accomodate the automatically enlarge by assign
        //in matlab at the start of the while-loop
        if ((m_ + 1) == initListValues_.n_cols) {
          initListValues_.resize(initListValues_.n_rows, initListValues_.n_cols + step_);
        }
        if ((nboxes_ + step_) > dim_) {
          //TODO: are the additional elements automatically set to zero? if not, need to do that
          isplit_.resize(nboxes_ + step_);
          level_.resize(nboxes_ + step_);
          ipar_.resize(nboxes_ + step_);
          ichild_.resize(nboxes_ + step_);
          z_.resize(z_.n_rows, nboxes_ + step_);
          nogain_.resize(nboxes_ + step_);
          boxBaseVertexFunctionValues_.resize(z_.n_rows, nboxes_ + step_);
          dim_ = nboxes_ + step_;
        }
        if (this->isFinished() || this->isTerminated()) {
          break;
        }
      } else {//no splitting, increase the level by 1
        if (minimalLevel + 1 < boxDivisions_) {
          level_(par) = minimalLevel + 1;
          //index again so use 0, matlab=1

          updateRecord(par, minimalLevel + 1, boxBaseVertexFunctionValues_.row(0).t());
        } else {
          level_(par) = 0;
          nbasket_++;
          pointsInBasket_.col(nbasket_ - 1) = baseVertex_;
          //index again so use 0, matlab=1
          pointsInBasketValue_(nbasket_ - 1) = boxBaseVertexFunctionValues_(0, par);
        }
      } //end of prepare for splitting
      minimalLevel++;
      while (minimalLevel < boxDivisions_) {
        if (record_(minimalLevel - 1) == 0) {
          minimalLevel++;
        } else {
          break;
        }
      }
      //if smax is reached, a new sweep is started
      if (minimalLevel == boxDivisions_) {
        if (maxLocalSearchSteps_ > 0) {
          //original matlab sort: [fmi(nbasket0+1:nbasket),j] = sort(fmi(nbasket0+1:nbasket));
          //original matlab sort: xmin(:,nbasket0+1:nbasket) = xmin(:,nbasket0+j);
          arma::Col<unsigned int> sortedPIBV = arma::sort_index(pointsInBasketValue_.rows(nbasket0_, nbasket_ - 1));
          //since we sort over a subview the indexes will start at 0, but we use them for the whole matrix afterwards
          sortedPIBV += nbasket0_;
          pointsInBasketValue_.rows(nbasket0_, nbasket_ - 1) = arma::sort(pointsInBasketValue_.rows(nbasket0_, nbasket_ - 1));
          pointsInBasket_.cols(nbasket0_, nbasket_ - 1) = pointsInBasket_.cols(sortedPIBV);

          for (int j = nbasket0_; j < nbasket_; j++) {
            //programmatically it seems dumb to overwrite a global variable, but they do it in matlab.
            baseVertex_ = pointsInBasket_.col(j);
            //unfortunately multiple return values of primitives are needed later, so we have to use pointers
            //f1 is already a vector earlier. Why is he overwriting it in matlab??
            std::shared_ptr<double> f1(new double(pointsInBasketValue_(j)));

            if (checkLocationNotUsed(baseVertex_)) {
              addLocation(baseVertex_);

              //intentionally nbasket0, not -1
              bool isInside = pointInsideDomainOfAttraction(baseVertex_, f1, nbasket0_);
              if (this->isFinished() || this->isTerminated()) {
                return;
              }
              if (isInside) {
                ///////////////////////////TODO: CONTROL IF LSEARCH IS WORKING CORRECTLY AS INTENDED!///////////////////////////
                localSearch_->setInitialParameter(baseVertex_);
                localSearch_->setMaximalNumberOfIterations(localSearch_->getNumberOfIterations() + maxLocalSearchSteps_);
                localSearch_->optimise();
                arma::Col<double> xminTemp = localSearch_->getBestParameter();
                double fmiTemp = localSearch_->getBestObjectiveValue();

                if (fmiTemp < this->bestObjectiveValue_) {
                  this->bestParameter_ = xminTemp;
                  this->bestObjectiveValue_ = fmiTemp;
                  if (this->isFinished() || this->isTerminated()) {
                    nbasket0_++;
                    nbasket_ = nbasket0_;
                    pointsInBasket_.col(nbasket_ - 1) = xminTemp;
                    pointsInBasketValue_(nbasket_ - 1) = fmiTemp;
                    break;
                  }
                }
                //intentionally nbasket0, not -1
                bool candidateInside = candidateInsideDomainOfAttraction(xminTemp, fmiTemp, nbasket0_);
                if (candidateInside) {
                  nbasket0_++;
                  pointsInBasket_.col(nbasket0_ - 1) = xminTemp;
                  pointsInBasketValue_(nbasket0_ - 1) = fmiTemp;
                  //TODO: this check seems redundant, should check if it ever gets called
                  if (pointsInBasketValue_(nbasket0_ - 1) < this->bestObjectiveValue_) {
                    this->bestObjectiveValue_ = pointsInBasketValue_(nbasket0_ - 1);
                    this->bestParameter_ = pointsInBasket_.col(nbasket0_ - 1);
                    if (this->isFinished() || this->isTerminated()) {
                      nbasket_ = nbasket0_;
                      return;
                    }
                  }
                }
              }
            }
          }
          nbasket_ = nbasket0_;
          if (this->isFinished() || this->isTerminated()) {
            return;
          }
        }
        minimalLevel = startSweep();
      }
    }
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::initBoxes() noexcept {
    //for convenience
    const unsigned int numberOfDimensions = this->optimisationProblem_->numberOfDimensions_;

    //parameter values of box 1
    ipar_(0) = 0;
    level_(0) = 1;
    ichild_(0) = 1;
    boxBaseVertexFunctionValues_(0, 0) = initListValues_(initialPointIndex_(0), 0);

    int parent = 0;

    arma::Col<double> var = arma::Col<double>(numberOfDimensions);

    for (int i = 0; i < numberOfDimensions; i++) {
      isplit_(parent) = -(i + 1); //boxes split in the init. procedure get a negative splitting index
      int nchild = 0;
      if (x0_(i, 0) > boundaries_.col(0)(i)) {
        nboxes_++;
        nchild++;
        genBox(nboxes_ - 1, parent, level_(parent) + 1, -nchild, initListValues_(0, i));
      }

      double v1 = 0;
      //in matlab there is more logic applied to v1, but since popSize is fixed for all dimensions, it doesn't matter
      if (this->populationSize_ == 3) {
        v1 = boundaries_.col(1)(i);
      } else {
        v1 = x0_(i, 2);
      }

      arma::Col<double> d = quadraticPolynomialInterpolation(x0_.submat(i, 0, i, 2).t(), initListValues_.submat(0, i, 2, i));
      double xl = minimumQuadraticPolynomial(boundaries_.col(0)(i), v1, d, x0_.submat(i, 0, i, 2));
      double fl = quadraticPolynomial(xl, d, x0_.submat(i, 0, i, 2));
      double xu = minimumQuadraticPolynomial(boundaries_.col(0)(i), v1, -d, x0_.submat(i, 0, i, 2));
      double fu = quadraticPolynomial(xu, d, x0_.submat(i, 0, i, 2));

      int par1 = 0; //label of the current box for the next coordinate
      if (bestPointIndex_(i) == 0) {
        if (xl < x0_(i, 0)) {
          par1 = nboxes_;
        } else {
          par1 = nboxes_ + 1;
        }
      }
      for (std::size_t j = 0; j < this->populationSize_ - 1; j++) {
        nboxes_++;
        nchild++;
        int s = 0;
        if (initListValues_(j, i) <= initListValues_(j + 1, i)) {
          s = 1;
        } else {
          s = 2;
        }
        genBox(nboxes_ - 1, parent, level_(parent) + s, -nchild, initListValues_(j, i));
        if (j >= 1) {
          if (bestPointIndex_(i) == j) {
            if (xl <= x0_(i, j)) {
              par1 = nboxes_ - 1;
            } else {
              par1 = nboxes_;
            }
          }
          if (j <= this->populationSize_ - 3) {
            d = quadraticPolynomialInterpolation(x0_.submat(i, j, i, j + 2), initListValues_.submat(j, i, j + 2, i));
            double u1 = 0;
            if (j < this->populationSize_ - 3) {
              u1 = x0_(i, j + 2);
            } else {
              u1 = boundaries_.col(1)(i);
            }
            xl = minimumQuadraticPolynomial(x0_(i, j), u1, d, x0_.submat(i, j, i, j + 2));
            fl = std::min(quadraticPolynomial(xl, d, x0_.submat(i, j, i, j + 2)), fl);
            xu = minimumQuadraticPolynomial(x0_(i, j), u1, -d, x0_.submat(i, j, i, j + 2));
            fu = std::max(quadraticPolynomial(xu, d, x0_.submat(i, j, i, j + 2)), fu);
          }
        }
        nboxes_++;
        nchild++;
        genBox(nboxes_ - 1, parent, level_(parent) + 3 - s, -nchild, initListValues_(j + 1, i));
      }
      if (x0_(i, this->populationSize_ - 1) < boundaries_.col(0)(i)) {
        nboxes_++;
        nchild++;
        genBox(nboxes_ - 1, parent, level_(parent) + 1, -nchild, initListValues_(this->populationSize_ - 1, i));
      }
      if (bestPointIndex_(i) == this->populationSize_ - 1) {
        if (x0_(i, this->populationSize_ - 1) < boundaries_.col(0)(i)) {
          if (xl <= x0_(i, this->populationSize_ - 1)) {
            par1 = nboxes_ - 1;
          } else {
            par1 = nboxes_;
          }
        } else {
          par1 = nboxes_;
        }
      }
      var(i) = fu - fl; // the quadratic model is taken as a crude measure of the variability in the ith component
      level_(parent) = 0; //box is marked as split
      parent = par1 - 1;
    }
    //from matlab: best function value after the init. procedure
    //doesnt make much sense to me since we never changed initListEvaluations
    this->bestObjectiveValue_ = initListValues_(bestPointIndex_(numberOfDimensions - 1), numberOfDimensions - 1);
    for (std::size_t i = 0; i < numberOfDimensions; i++) {
      //next two lines should equal [var0,p(i)] = max(var)
      var.max(variabilityRanking_(i));
      var(variabilityRanking_(i)) = -1;
      this->bestParameter_(i) = x0_(i, bestPointIndex_(i)); //best point after the init. procedure
    }
  }

  template <typename ParameterType>
  std::string MultilevelCoordinateSearch<ParameterType>::to_string() const noexcept {
    return "MultilevelCoordinateSearch";
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::genBox(int nbox, int par, int level, int nchild, double baseVertexFunctionValue) noexcept {
    //since par is matlab-1 in value, and we want matlab value in ipar_
    ipar_(nbox) = par + 1;
    level_(nbox) = level;
    ichild_(nbox) = nchild;
    boxBaseVertexFunctionValues_(0, nbox) = baseVertexFunctionValue;
  }

  template <typename ParameterType>
  arma::Col<double> MultilevelCoordinateSearch<ParameterType>::quadraticPolynomialInterpolation(arma::Col<double> supportPoints, arma::Col<double> functionValues) const noexcept {
    arma::Col<double> d(3);
    d(0) = functionValues(0);
    d(1) = (functionValues(1) - functionValues(0)) / (supportPoints(1) - supportPoints(0));
    double f23 = (functionValues(2) - functionValues(1)) / (supportPoints(2) - supportPoints(1));
    d(2) = (f23 - d(1)) / (supportPoints(2) - supportPoints(0));
    return d;
  }

  template <typename ParameterType>
  double MultilevelCoordinateSearch<ParameterType>::minimumQuadraticPolynomial(double a, double b, arma::Col<double> d, arma::Mat<double> x0_fragment) const noexcept {
    double x = 0;
    if (d(2) == 0) {
      if (d(1) > 0) {
        x = a;
      } else {
        x = b;
      }
      return x;
    } else if (d(2) > 0) {
      double x1 = 0.5 * (x0_fragment(0) + x0_fragment(1)) - 0.5 * (d(1) / d(2));
      if (a <= x1 && x1 <= b) {
        x = x1;
      } else if (quadraticPolynomial(a, d, x0_fragment) < quadraticPolynomial(b, d, x0_fragment)) {
        x = a;
      } else {
        x = b;
      }
    } else {
      if (quadraticPolynomial(a, d, x0_fragment) < quadraticPolynomial(b, d, x0_fragment)) {
        x = a;
      } else {
        x = b;
      }
    }
    return x;
  }

  template <typename ParameterType>
  double MultilevelCoordinateSearch<ParameterType>::quadraticPolynomial(double x, arma::Col<double> d, arma::Mat<double> x0_fragment) const noexcept {
    return d(0) + d(1)*(x - x0_fragment(0)) + d(2)*(x - x0_fragment(0))*(x - x0_fragment(1));
  }

  template <typename ParameterType>
  double MultilevelCoordinateSearch<ParameterType>::splitByGoldenSectionRule(double x1, double x2, double f1, double f2) const noexcept {
    if (f1 <= f2) {
      return x1 + 0.5 * (-1 + std::sqrt(5))*(x2 - x1);
    } else {
      return x1 + 0.5 * (3 - std::sqrt(5))*(x2 - x1);
    }
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::splitByRank(unsigned int par, unsigned int numberOfDimensions, arma::Col<unsigned int> n0) noexcept {
    isplit_(par) = 1;
    int n1 = n0(0);
    int p1 = variabilityRanking_(0);
    //matlab starts at 2
    for (int i = 1; i < numberOfDimensions; i++) {
      if (n0(i) < n1 || (n0(i) == n1 && variabilityRanking_(i) < p1)) {
        isplit_(par) = i + 1;
        n1 = n0(i);
        p1 = variabilityRanking_(i);
      }
    }
    if (n1 > 0) {
      z_(1, par) = splitBySubint(baseVertex_(isplit_(par) - 1), oppositeVertex_(isplit_(par) - 1));
    } else {
      z_(1, par) = arma::datum::inf;
    }
  }

  template <typename ParameterType>
  double MultilevelCoordinateSearch<ParameterType>::splitBySubint(double x, double y) const noexcept {
    double x2 = y;
    if (x == 0 && std::abs(y) > 1000) {
      x2 = std::copysign(1.0, y);
    } else if (x != 0 && std::abs(y) > 100 * std::abs(x)) {
      //TODO: c++ standardlibraries have no signum. wat. using copysign instead...
      //original matlab: x2 = 10.*sign(y)*abs(x);
      x2 = 10 * std::copysign(x, y);
    }
    return x + 2 * (x2 - x) / 3.0;
  }

  template <typename ParameterType>
  bool MultilevelCoordinateSearch<ParameterType>::splitByInitList(unsigned int splittingIndex, unsigned int minimalLevel, unsigned int par) noexcept {
    arma::Col<double> x = baseVertex_;
    initListValues_.col(m_ - 1).zeros();
    for (int j = 0; j < this->populationSize_; j++) {
      if (j != initialPointIndex_(splittingIndex)) {
        x(splittingIndex) = x0_(splittingIndex, j);
        initListValues_.col(m_ - 1)(j) = this->optimisationProblem_->getObjectiveValue(x);
        this->numberOfIterations_++;
        if (initListValues_.col(m_ - 1)(j) < this->bestObjectiveValue_) {
          this->bestObjectiveValue_ = initListValues_.col(m_ - 1)(j);
          this->bestParameter_ = x;
        }
        //In matlab this if is a little different and inside the if directly before this.
        //Our stopping conditions are a little different so it's here.
        if (this->isFinished() || this->isTerminated()) {
          return true;
        }
      } else {
        //index again so use 0, matlab=1
        initListValues_.col(m_ - 1)(j) = boxBaseVertexFunctionValues_(0, par);
      }
    }
    if (minimalLevel + 1 < boxDivisions_) {
      int nchild = 0;
      //index again so use 0, matlab=1
      if (boundaries_.col(0)(splittingIndex) < x0_(splittingIndex, 0)) {//in that case the box at the boundary gets level s + 1
        nchild++;
        nboxes_++;
        //index again so use 0, matlab=1
        genBox(nboxes_ - 1, par, minimalLevel + 1, -nchild, initListValues_.col(m_ - 1)(0));
        //index again so use 0, matlab=1
        updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
      }
      for (int j = 0; j < this->populationSize_ - 1; j++) {
        nchild++;
        int level0 = 0;
        if (initListValues_.col(m_ - 1)(j) <= initListValues_.col(m_ - 1)(j + 1) || minimalLevel + 2 < boxDivisions_) {
          nboxes_++;
          if (initListValues_.col(m_ - 1)(j) <= initListValues_.col(m_ - 1)(j + 1)) {
            level0 = minimalLevel + 1;
          } else {
            level0 = minimalLevel + 2;
          }
          genBox(nboxes_ - 1, par, level0, -nchild, initListValues_.col(m_ - 1)(j));
          //index again so use 0, matlab=1
          updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
        } else {
          x(splittingIndex) = x0_(splittingIndex, j);
          nbasket_++;
          pointsInBasket_.col(nbasket_ - 1) = x;
          pointsInBasketValue_(nbasket_ - 1) = initListValues_.col(m_ - 1)(j);
        }
        nchild++;
        if (initListValues_.col(m_ - 1)(j + 1) < initListValues_.col(m_ - 1)(j) || minimalLevel + 2 < boxDivisions_) {
          nboxes_++;
          if (initListValues_.col(m_ - 1)(j + 1) < initListValues_.col(m_ - 1)(j)) {
            level0 = minimalLevel + 1;
          } else {
            level0 = minimalLevel + 2;
          }
          genBox(nboxes_ - 1, par, level0, -nchild, initListValues_.col(m_ - 1)(j + 1));
          //index again so use 0, matlab=1
          updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
        } else {
          x(splittingIndex) = x0_(splittingIndex, j + 1);
          nbasket_++;
          pointsInBasket_.col(nbasket_ - 1) = x;
          pointsInBasketValue_(nbasket_ - 1) = initListValues_.col(m_ - 1)(j + 1);
        }
      }
      if (x0_(splittingIndex, this->populationSize_ - 1) < boundaries_.col(1)(splittingIndex)) {//in that case the box at the boundary gets level s + 1
        nchild++;
        nboxes_++;
        genBox(nboxes_ - 1, par, minimalLevel + 1, -nchild, initListValues_.col(m_ - 1)(this->populationSize_ - 1));
        //index again so use 0, matlab=1
        updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
      }
    } else {
      for (int j = 0; j < this->populationSize_; j++) {
        x(splittingIndex) = x0_(splittingIndex, j);
        nbasket_++;
        pointsInBasket_.col(nbasket_ - 1) = x;
        pointsInBasketValue_(nbasket_ - 1) = initListValues_.col(m_ - 1)(j);
      }
    }
    return this->isFinished() || this->isTerminated();
  }

  template <typename ParameterType>
  bool MultilevelCoordinateSearch<ParameterType>::split(unsigned int splittingIndex, unsigned int minimalLevel, unsigned int par) noexcept {
    arma::Col<double> x = baseVertex_;
    arma::Col<double> z = z_.col(par);
    x(splittingIndex) = z(1);
    boxBaseVertexFunctionValues_(1, par) = this->optimisationProblem_->getObjectiveValue(x);
    this->numberOfIterations_++;
    //index again so use 1, matlab=2
    if (boxBaseVertexFunctionValues_(1, par) < this->bestObjectiveValue_) {
      //index again so use 1, matlab=2
      this->bestObjectiveValue_ = boxBaseVertexFunctionValues_(1, par);
      this->bestParameter_ = x;
      //Our stopping conditions are a little different
      if (this->isFinished() || this->isTerminated()) {
        return true;
      }
    }

    if (minimalLevel + 1 < boxDivisions_) {
      //index again, all decremented by 1
      if (boxBaseVertexFunctionValues_(0, par) < boxBaseVertexFunctionValues_(1, par)) {
        nboxes_++;
        //index again so use 0, matlab=1
        genBox(nboxes_ - 1, par, minimalLevel + 1, 1, boxBaseVertexFunctionValues_(0, par));
        //index again so use 0, matlab=1
        updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
        if (minimalLevel + 2 < boxDivisions_) {
          nboxes_++;
          //index again so use 1, matlab=2
          genBox(nboxes_ - 1, par, minimalLevel + 2, 2, boxBaseVertexFunctionValues_(1, par));
          //index again so use 0, matlab=1
          updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
        } else {
          //index again so use 1, matlab=2
          x(splittingIndex) = z(1);
          nbasket_ = nbasket_ + 1;
          pointsInBasket_.col(nbasket_ - 1) = x;
          //index again so use 1, matlab=2
          pointsInBasketValue_(nbasket_ - 1) = boxBaseVertexFunctionValues_(1, par);
        }

      } else {
        if (minimalLevel + 2 < boxDivisions_) {
          nboxes_++;
          //index again so use 0, matlab=1
          genBox(nboxes_ - 1, par, minimalLevel + 2, 1, boxBaseVertexFunctionValues_(0, par));
          //index again so use 0, matlab=1
          updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
        } else {
          //index again so use 0, matlab=1
          x(splittingIndex) = z(0);
          nbasket_ = nbasket_ + 1;
          pointsInBasket_.col(nbasket_ - 1) = x;
          //index again so use 0, matlab=1
          pointsInBasketValue_(nbasket_ - 1) = boxBaseVertexFunctionValues_(0, par);
        }
        nboxes_++;
        //index again so use 1, matlab=2
        genBox(nboxes_ - 1, par, minimalLevel + 1, 2, boxBaseVertexFunctionValues_(1, par));
        //index again so use 0, matlab=1
        updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
      }

      // if the third box is larger than the smaller of the other two boxes,
      // it gets level s + 1; otherwise it gets level s + 2
      //index again so use 1, matlab=2
      if (z(1) != oppositeVertex_(splittingIndex)) {
        //index again so use 1, matlab=2
        if (std::abs(z(1) - oppositeVertex_(splittingIndex)) > std::abs(z(1) - z(0))*(3 - std::sqrt(5))*0.5) {
          nboxes_++;
          //index again so use 1, matlab=2
          genBox(nboxes_ - 1, par, minimalLevel + 1, 3, boxBaseVertexFunctionValues_(1, par));
          //index again so use 0, matlab=1
          updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
        } else {
          if (minimalLevel + 2 < boxDivisions_) {
            nboxes_++;
            //index again so use 1, matlab=2
            genBox(nboxes_ - 1, par, minimalLevel + 2, 3, boxBaseVertexFunctionValues_(1, par));
            //index again so use 0, matlab=1
            updateRecord(nboxes_ - 1, level_(nboxes_ - 1), boxBaseVertexFunctionValues_.row(0).t());
          } else {
            //index again so use 1, matlab=2
            x(splittingIndex) = z(1);
            nbasket_ = nbasket_ + 1;
            pointsInBasket_.col(nbasket_ - 1) = x;
            //index again so use 1, matlab=2
            pointsInBasketValue_(nbasket_ - 1) = boxBaseVertexFunctionValues_(1, par);
          }
        }
      }
    } else {
      //TODO: this is what is actually written in matlab. It makes zero sense to overwrite what was done before. May be an error in matlab?
      //index again so use 0, matlab=1
      x(splittingIndex) = z(0);
      nbasket_ = nbasket_ + 1;
      pointsInBasket_.col(nbasket_ - 1) = x;
      //index again so use 0, matlab=1
      pointsInBasketValue_(nbasket_ - 1) = boxBaseVertexFunctionValues_(0, par);

      //index again so use 1, matlab=2
      x(splittingIndex) = z(1);
      nbasket_ = nbasket_ + 1;
      pointsInBasket_.col(nbasket_ - 1) = x;
      //index again so use 1, matlab=2
      pointsInBasketValue_(nbasket_ - 1) = boxBaseVertexFunctionValues_(1, par);
    }
    return this->isFinished() || this->isTerminated();
  }

  template <typename ParameterType>
  arma::Col<double> MultilevelCoordinateSearch<ParameterType>::expectedGainOfSplit(unsigned int par, unsigned int numberOfDimensions, arma::Col<unsigned int> n0, arma::Col<double> x1, arma::Col<double> x2, arma::Col<double> f1, arma::Col<double> f2) noexcept {
    double emin = arma::datum::inf;
    arma::Col<double> expectedGain = arma::Col<double>(numberOfDimensions);
    for (int i = 0; i < numberOfDimensions; i++) {
      if (n0(i) == 0) {
        //expected gain for splitting according to the initialization list
        expectedGain(i) = arma::min(initListValues_.col(i)) - initListValues_(initialPointIndex_(i), i);
        if (expectedGain(i) < emin) {
          emin = expectedGain(i);
          isplit_(par) = i + 1;
          //index again so use 1, matlab=2
          z_(1, par) = arma::datum::inf;
        }
      } else {
        arma::Col<double> z1;
        z1 << baseVertex_(i) << x1(i) << x2(i) << arma::endr;
        //index again at "boxBaseVertexFunctionValues_(0,par)" so use 0, matlab=1
        arma::Col<double> z2;
        z2 << 0 << f1(i) - boxBaseVertexFunctionValues_(0, par) << f2(i) - boxBaseVertexFunctionValues_(0, par) << arma::endr;
        arma::Col<double> d = quadraticPolynomialInterpolation(z1, z2);
        arma::Col<double> eta = subint(baseVertex_(i), oppositeVertex_(i));
        //safeguard against splitting too close to x(i)
        double xi1 = arma::min(eta);
        double xi2 = arma::max(eta);
        double z = minimumQuadraticPolynomial(xi1, xi2, d, z1);
        expectedGain(i) = quadraticPolynomial(z, d, z1);
        if (expectedGain(i) < emin) {
          emin = expectedGain(i);
          isplit_(par) = i + 1;
          //index again so use 1, matlab=2
          z_(1, par) = z;
        }
      }
    }
    return expectedGain;
  }

  template <typename ParameterType>
  unsigned int MultilevelCoordinateSearch<ParameterType>::startSweep() noexcept {
    record_ = arma::Col<unsigned int>(boxDivisions_ - 1, arma::fill::zeros);
    unsigned int s = boxDivisions_;
    for (unsigned int i = 0; i < nboxes_; i++) {
      if (level_(i) > 0) {
        if (level_(i) < s) {
          s = level_(i);
        }
        if (!record_(level_(i) - 1)) {
          record_(level_(i) - 1) = i + 1;
        } else if (boxBaseVertexFunctionValues_(0, i) < boxBaseVertexFunctionValues_(0, record_(level_(i) - 1) - 1)) {
          record_(level_(i) - 1) = i + 1;
        }
      }
    }
    return s;
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::vertex(unsigned int par, arma::Col<double>& x1, arma::Col<double>& x2, arma::Col<double>& f1, arma::Col<double>& f2, arma::Col<unsigned int>& n0) noexcept {
    //for convenience
    unsigned int numberOfDimensions = this->optimisationProblem_->numberOfDimensions_;

    baseVertex_ = arma::Col<double>(numberOfDimensions);
    baseVertex_.fill(arma::datum::inf);
    oppositeVertex_ = arma::Col<double>(numberOfDimensions);
    oppositeVertex_.fill(arma::datum::inf);

    double fold = boxBaseVertexFunctionValues_(0, par);
    unsigned int mVertex = par;
    while (mVertex > 0) {
      unsigned int i = std::abs(std::abs(isplit_(ipar_(mVertex) - 1)) - 1);
      n0(i) = n0(i) + 1;
      if (ichild_(mVertex) == 1) {
        if (baseVertex_(i) == arma::datum::inf || baseVertex_(i) == z_(0, ipar_(mVertex) - 1)) {
          //matlab passes 2, but it's used as an index so we need to use 1
          vert1(i, 1, mVertex, baseVertex_, x1, x2, f1, f2);
        } else {
          updtf(numberOfDimensions, i, fold, x1, x2, f1, f2, boxBaseVertexFunctionValues_(0, ipar_(mVertex) - 1));
          fold = boxBaseVertexFunctionValues_(0, ipar_(mVertex) - 1);
          //matlab passes 1, but it's used as an index so we need to use 0
          vert2(i, 0, mVertex, baseVertex_, x1, x2, f1, f2);
        }
      } else if (ichild_(mVertex) >= 2) {
        updtf(numberOfDimensions, i, fold, x1, x2, f1, f2, boxBaseVertexFunctionValues_(0, ipar_(mVertex) - 1));
        fold = boxBaseVertexFunctionValues_(0, ipar_(mVertex) - 1);
        if (baseVertex_(i) == arma::datum::inf || baseVertex_(i) == z_(1, ipar_(mVertex) - 1)) {
          //matlab passes 1, but it's used as an index so we need to use 0
          vert1(i, 0, mVertex, baseVertex_, x1, x2, f1, f2);
        } else {
          //matlab passes 2, but it's used as an index so we need to use 1
          vert2(i, 1, mVertex, baseVertex_, x1, x2, f1, f2);
        }
      }
      //matlab checks for 1/2, since it's index use 0/1
      //original matlab code: 1 <= ichild(m) & ichild(m) <= 2 & y(i) == Inf
      if ((ichild_(mVertex) == 1 || ichild_(mVertex) == 2) && oppositeVertex_(i) == arma::datum::inf) {
        oppositeVertex_(i) = splitByGoldenSectionRule(z_(0, ipar_(mVertex) - 1), z_(1, ipar_(mVertex) - 1), boxBaseVertexFunctionValues_(0, ipar_(mVertex) - 1), boxBaseVertexFunctionValues_(1, ipar_(mVertex) - 1));
      }
      //box m was generated by splitting according to the init. list
      if (ichild_(mVertex) < 0) {
        int j1 = 0; //has matlab-1 value
        int j2 = 0; //has matlab value
        int j3 = 0; //has matlab
        int k = 0; //has matlab-1 value
        if (boundaries_.col(0)(i) < x0_(i, 0)) {
          j1 = std::ceil(std::abs(ichild_(mVertex)) / 2.0);
          j2 = std::floor(std::abs(ichild_(mVertex)) / 2.0);
          if ((std::abs(ichild_(mVertex)) / 2.0 < j1 && j1 > 1) || j1 == this->populationSize_) {
            j3 = -1;
          } else {
            j3 = 1;
          }
        } else {
          j1 = std::floor(std::abs(ichild_(mVertex)) / 2.0) + 1;
          j2 = std::ceil(std::abs(ichild_(mVertex)) / 2.0);
          if ((std::abs(ichild_(mVertex)) / 2.0 + 1) > j1 && j1 < this->populationSize_) {
            j3 = 1;
          } else {
            j3 = -1;
          }
        }
        //box m was generated in the init. procedure
        if (isplit_(ipar_(mVertex) - 1) < 0) {
          k = i;
          //box m was generated by a later split according to the init.list
          //k points to the corresponding function values  
        } else {
          //matlab passes 2, but it's used as an index so we need to use 1
          //have to -1 so it stays at matlab-1 value
          k = z_(1, ipar_(mVertex) - 1) - 1;
        }
        j1--;

        if (j1 != initialPointIndex_(i) || (baseVertex_(i) != arma::datum::inf && baseVertex_(i) != x0_(i, (initialPointIndex_(i))))) {
          updtf(numberOfDimensions, i, fold, x1, x2, f1, f2, initListValues_(initialPointIndex_(i), k));
          fold = initListValues_(initialPointIndex_(i), k);
        }
        if (baseVertex_(i) == arma::datum::inf || baseVertex_(i) == x0_(i, j1)) {
          baseVertex_(i) = x0_(i, j1);
          if (x1(i) == arma::datum::inf) {
            vert3(i, j1, k, x1, x2, f1, f2);
          } else if (x2(i) == arma::datum::inf && x1(i) != x0_(i, j1 + j3)) {
            x2(i) = x0_(i, j1 + j3);
            f2(i) = f2(i) + initListValues_(j1 + j3, k);
          } else if (x2(i) == arma::datum::inf) {
            //matlab checks for 1, since it's index use 0
            if (j1 != 0 && j1 != this->populationSize_ - 1) {
              x2(i) = x0_(i, j1 - j3);
              f2(i) = f2(i) + initListValues_(j1 - j3, k);
            } else {
              x2(i) = x0_(i, j1 + 2 * j3);
              f2(i) = f2(i) + initListValues_(j1 + 2 * j3, k);
            }
          }
        } else {
          if (x1(i) == arma::datum::inf) {
            x1(i) = x0_(i, j1);
            f1(i) = f1(i) + initListValues_(j1, k);
            if (baseVertex_(i) != x0_(i, j1 + j3)) {
              x2(i) = x0_(i, j1 + j3);
              f2(i) = f2(i) + initListValues_(j1 + j3, k);
            }
          } else if (x2(i) == arma::datum::inf) {
            if (x1(i) != x0_(i, j1)) {
              x2(i) = x0_(i, j1);
              f2(i) = f2(i) + initListValues_(j1, k);
            } else if (baseVertex_(i) != x0_(i, j1 + j3)) {
              x2(i) = x0_(i, j1 + j3);
              f2(i) = f2(i) + initListValues_(j1 + j3, k);
            } else {
              //matlab checks for 1, since it's index use 0
              if (j1 != 0 && j1 != this->populationSize_ - 1) {
                x2(i) = x0_(i, j1 - j3);
                f2(i) = f2(i) + initListValues_(j1 - j3, k);
              } else {
                x2(i) = x0_(i, j1 + 2 * j3);
                f2(i) = f2(i) + initListValues_(j1 + 2 * j3, k);
              }
            }
          }
        }
        if (oppositeVertex_(i) == arma::datum::inf) {
          if (j2 == 0) {
            oppositeVertex_(i) = boundaries_.col(0)(i);
          } else if (j2 == this->populationSize_) {
            oppositeVertex_(i) = boundaries_.col(1)(i);
          } else {
            //added -1 to all j2 and k since they have matlab value.
            oppositeVertex_(i) = splitByGoldenSectionRule(x0_(i, j2 - 1), x0_(i, j2 + 1 - 1), initListValues_(j2 - 1, k), initListValues_(j2 + 1 - 1, k));
          }
        }
      }
      mVertex = ipar_(mVertex) - 1;
    }
    for (int i = 0; i < numberOfDimensions; i++) {
      if (baseVertex_(i) == arma::datum::inf) {
        baseVertex_(i) = x0_(i, initialPointIndex_(i));
        vert3(i, initialPointIndex_(i), i, x1, x2, f1, f2);
      }
      if (oppositeVertex_(i) == arma::datum::inf) {
        oppositeVertex_(i) = originalOppositeVertex_(i);
      }
    }
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::vert1(int updateIndex, unsigned int j, unsigned int m, arma::Col<double>& x, arma::Col<double>& x1, arma::Col<double>& x2, arma::Col<double>& f1, arma::Col<double>& f2) noexcept {
    int j1 = 0;
    //matlab checks for 1, since it's index use 0
    if (j == 0) {
      //also index again
      j1 = 1;
    } else {
      j1 = 0;
    }
    x(updateIndex) = z_(j1, ipar_(m) - 1);
    if (x1(updateIndex) == arma::datum::inf) {
      x1(updateIndex) = z_(j, ipar_(m) - 1);
      f1(updateIndex) = f1(updateIndex) + boxBaseVertexFunctionValues_(j, ipar_(m) - 1);
    } else if (x2(updateIndex) == arma::datum::inf && x1(updateIndex) != z_(j, ipar_(m) - 1)) {
      x2(updateIndex) = z_(j, ipar_(m) - 1);
      f2(updateIndex) = f2(updateIndex) + boxBaseVertexFunctionValues_(j, ipar_(m) - 1);
    }
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::vert2(int updateIndex, unsigned int j, unsigned int m, arma::Col<double> x, arma::Col<double>& x1, arma::Col<double>& x2, arma::Col<double>& f1, arma::Col<double>& f2) noexcept {
    int j1 = 0;
    //matlab checks for 1, since it's index use 0
    if (j == 0) {
      //also index again
      j1 = 1;
    } else {
      j1 = 0;
    }
    if (x1(updateIndex) == arma::datum::inf) {
      x1(updateIndex) = z_(j, ipar_(m) - 1);
      f1(updateIndex) = f1(updateIndex) + boxBaseVertexFunctionValues_(j, ipar_(m) - 1);
      if (x(updateIndex) != z_(j1, ipar_(m) - 1)) {
        x2(updateIndex) = z_(j1, ipar_(m) - 1);
        f2(updateIndex) = f2(updateIndex) + boxBaseVertexFunctionValues_(j1, ipar_(m) - 1);
      }
    } else if (x2(updateIndex) == arma::datum::inf && x1(updateIndex) != z_(j, ipar_(m) - 1)) {
      x2(updateIndex) = z_(j, ipar_(m) - 1);
      f2(updateIndex) = f2(updateIndex) + boxBaseVertexFunctionValues_(j, ipar_(m) - 1);
    } else if (x2(updateIndex) == arma::datum::inf) {
      x2(updateIndex) = z_(j1, ipar_(m) - 1);
      f2(updateIndex) = f2(updateIndex) + boxBaseVertexFunctionValues_(j1, ipar_(m) - 1);
    }
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::vert3(int updateIndex, unsigned int j, const int& f0columnIndex, arma::Col<double>& x1, arma::Col<double>& x2, arma::Col<double>& f1, arma::Col<double>& f2) noexcept {
    int k1 = 0;
    int k2 = 0;
    //matlab checks for 1, since it's index use 0
    if (j == 0) {
      //also index again
      k1 = 1;
      k2 = 2;
      //decremented cause index
    } else if (j == this->populationSize_ - 1) {
      //decremented cause index
      k1 = this->populationSize_ - 3;
      k2 = this->populationSize_ - 2;
    } else {
      k1 = j - 1;
      k2 = j + 1;
    }
    x1(updateIndex) = x0_(updateIndex, k1);
    x2(updateIndex) = x0_(updateIndex, k2);
    f1(updateIndex) = f1(updateIndex) + initListValues_(k1, f0columnIndex);
    f2(updateIndex) = f2(updateIndex) + initListValues_(k2, f0columnIndex);
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::updtf(unsigned int numberOfDimensions, unsigned int splittingIndex, double fold, arma::Col<double> x1, arma::Col<double> x2, arma::Col<double>& f1, arma::Col<double>& f2, double baseVertexValueCurrentBox) noexcept {
    for (int i = 0; i < numberOfDimensions; i++) {
      if (i != splittingIndex) {
        if (x1(i) == arma::datum::inf) {
          f1(i) = f1(i) + fold - baseVertexValueCurrentBox;
        }
        if (x2(i) == arma::datum::inf) {
          f2(i) = f2(i) + fold - baseVertexValueCurrentBox;
        }
      }
    }
    //updtf.m sets fold = f here. since the inputvalue fold never gets changed, this doesn't actually belong here.
  }

  template <typename ParameterType>
  arma::Col<double> MultilevelCoordinateSearch<ParameterType>::subint(double x, double y) const noexcept {
    double x2 = y;
    int f = 1000;
    if (f * std::abs(x) < 1) {
      if (std::abs(y) > f) {
        x2 = std::copysign(1.0, y);
      }
    } else {
      if (std::abs(y) > f * std::abs(x)) {
        //c++ standardlibraries have no signum. using copysign instead...
        //original matlab: x2 = 10.*sign(y)*abs(x);
        x2 = 10 * std::copysign(std::abs(x), y);
      }
    }
    arma::Col<double> retVector(2);
    retVector(0) = x + (x2 - x) / 10.0;
    retVector(1) = x2;
    return retVector;
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::updateRecord(unsigned int label, int level, arma::Col<double> f) noexcept {
    if (record_.n_elem < level) {
      record_(level - 1) = label + 1;
    } else if (record_(level - 1) == 0) {
      record_(level - 1) = label + 1;
    } else if (f(label) < f(record_(level - 1) - 1)) {
      record_(level - 1) = label + 1;
    }
  }

  template <typename ParameterType>
  bool MultilevelCoordinateSearch<ParameterType>::checkLocationNotUsed(arma::Col<double> location) const noexcept {
    for (int i = 0; i < nloc_; i++) {
      //TODO: This might not work correctly
      if (arma::all(location == xloc_.col(i))) {
        return false;
      }
    }
    return true;
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::addLocation(arma::Col<double>& loc) noexcept {
    nloc_++;
    if (xloc_.n_cols < nloc_) {
      xloc_.resize(xloc_.n_cols + step_);
      xloc_.col(nloc_) = loc;
    } else {
      xloc_.col(nloc_) = loc;
    }
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::setLocalSearch(const std::shared_ptr<TrajectoryBasedOptimisationAlgorithm<ParameterType>> localSearch) {
    if (!localSearch) {
      throw std::invalid_argument("local search given is null!");
    }
    localSearch_ = localSearch;
  }

  template <typename ParameterType>
  bool MultilevelCoordinateSearch<ParameterType>::pointInsideDomainOfAttraction(arma::Col<double>& loc, std::shared_ptr<double> valueAtLoc, double nbasket) noexcept {
    if (nbasket == 0) {
      return true;
    }
    arma::Col<double> distancesToLoc(nbasket);
    for (int k = 0; k < nbasket; k++) {
      distancesToLoc(k) = arma::norm(loc - pointsInBasket_.col(k));
    }
    arma::Col<unsigned int> sortedDistances = arma::sort_index(distancesToLoc);
    for (int k = 0; k < nbasket; k++) {
      int i = sortedDistances(k);
      if (pointsInBasketValue_(i) <= *valueAtLoc) {
        arma::Col<double> p = pointsInBasket_.col(i) - loc;
        arma::Col<double> y1 = loc + (1 / 3.0) * p;
        double f1 = this->optimisationProblem_->getObjectiveValue(y1);
        this->numberOfIterations_++;
        if (f1 <= *valueAtLoc) {
          arma::Col<double> y2 = loc + (2 / 3.0) * p;
          double f2 = this->optimisationProblem_->getObjectiveValue(y2);
          this->numberOfIterations_++;
          if (f2 > std::max(f1, pointsInBasketValue_(i))) {
            if (f1 < *valueAtLoc) {
              loc = y1;
              *valueAtLoc = f1;
              if (*valueAtLoc < this->bestObjectiveValue_) {
                this->bestObjectiveValue_ = *valueAtLoc;
                this->bestParameter_ = loc;
                if (this->isFinished() || this->isTerminated()) {
                  return false;
                }
              }
            }
          } else {
            if (f1 < std::min(f2, pointsInBasketValue_(i))) {
              *valueAtLoc = f1;
              loc = y1;
              if (*valueAtLoc < this->bestObjectiveValue_) {
                this->bestObjectiveValue_ = *valueAtLoc;
                this->bestParameter_ = loc;
                if (this->isFinished() || this->isTerminated()) {
                  return false;
                }
              }
            } else if (f2 < std::min(f1, pointsInBasketValue_(i))) {
              *valueAtLoc = f2;
              loc = y2;
              if (*valueAtLoc < this->bestObjectiveValue_) {
                this->bestObjectiveValue_ = *valueAtLoc;
                this->bestParameter_ = loc;
                if (this->isFinished() || this->isTerminated()) {
                  return false;
                }
              }
            } else {
              return false;
            }
          }
        }
      }
    }
    return true;
  }

  template <typename ParameterType>
  bool MultilevelCoordinateSearch<ParameterType>::candidateInsideDomainOfAttraction(arma::Col<double> candidate, double valueAtCandidate, double nbasket) noexcept {
    if (nbasket == 0) {
      return true;
    }
    arma::Col<double> distancesToCandidate(nbasket);
    for (int k = 0; k < nbasket; k++) {
      distancesToCandidate(k) = arma::norm(candidate - pointsInBasket_.col(k));
    }
    arma::Col<unsigned int> sortedDistances = arma::sort_index(distancesToCandidate);
    for (int k = 0; k < nbasket; k++) {
      int i = sortedDistances(k);
      arma::Col<double> p = pointsInBasket_.col(i) - candidate;
      arma::Col<double> y1 = candidate + (1 / 3.0) * p;
      double f1 = this->optimisationProblem_->getObjectiveValue(y1);
      this->numberOfIterations_++;
      if (f1 <= std::max(pointsInBasketValue_(i), valueAtCandidate)) {
        arma::Col<double> y2 = candidate + (2 / 3.0) * p;
        double f2 = this->optimisationProblem_->getObjectiveValue(y2);
        this->numberOfIterations_++;
        if (f2 <= std::max(f1, pointsInBasketValue_(i))) {
          if (valueAtCandidate < std::min(std::min(f1, f2), pointsInBasketValue_(i))) {
            pointsInBasketValue_(i) = valueAtCandidate;
            pointsInBasket_.col(i) = candidate;
            if (valueAtCandidate < this->bestObjectiveValue_) {
              this->bestObjectiveValue_ = valueAtCandidate;
              this->bestParameter_ = candidate;
              if (this->isFinished() || this->isTerminated()) {
                return false;
              }
            }
            return false;
          } else if (f1 < std::min(std::min(valueAtCandidate, f2), pointsInBasketValue_(i))) {
            pointsInBasketValue_(i) = f1;
            pointsInBasket_.col(i) = y1;
            if (valueAtCandidate < this->bestObjectiveValue_) {
              this->bestObjectiveValue_ = valueAtCandidate;
              this->bestParameter_ = candidate;
              if (this->isFinished() || this->isTerminated()) {
                return false;
              }
            }
            return false;
          } else if (f2 < std::min(std::min(valueAtCandidate, f1), pointsInBasketValue_(i))) {
            pointsInBasketValue_(i) = f2;
            pointsInBasket_.col(i) = y2;
            if (valueAtCandidate < this->bestObjectiveValue_) {
              this->bestObjectiveValue_ = valueAtCandidate;
              this->bestParameter_ = candidate;
              if (this->isFinished() || this->isTerminated()) {
                return false;
              }
            }
            return false;
          } else {
            return false;
          }
        }
      }
    }
    return true;
  }
  // </editor-fold>

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::setBoxDivisions(const unsigned int divisions) {
    boxDivisions_ = divisions;
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::setMaximumLocalSearchSteps(const unsigned int steps) {
    maxLocalSearchSteps_ = steps;
  }

  template <typename ParameterType>
  void MultilevelCoordinateSearch<ParameterType>::initialPointSetup() {
    //l, L and x0_ are the custom initialisation list variables
    //l is supposed to point to the initial point x^0 in x0
    //l also never gets changed in matlab as far as i could see
    //L gives the amount of values per dimension (populationSize with more finetuning possible)
    //l will be initialPointIndex
    //L is completely replaced by populationSize
    
    //for convenience
    const unsigned int numberOfDimensions = this->optimisationProblem_->numberOfDimensions_;
    
    initialPointIndex_ = arma::Col<unsigned int>(numberOfDimensions, arma::fill::ones);

    arma::Col<double> initialPoint(numberOfDimensions, arma::fill::zeros);
    for (std::size_t i = 0; i < numberOfDimensions; i++) {
      initialPoint(i) = x0_(i, initialPointIndex_(i));
    }

    double valueForInitialPoint = this->optimisationProblem_->getObjectiveValue(initialPoint);
    initListValues_(0, initialPointIndex_(0)) = valueForInitialPoint;
    this->numberOfIterations_++;

    for (std::size_t i = 0; i < numberOfDimensions; i++) {
      bestPointIndex_(i) = initialPointIndex_(i);
      for (std::size_t j = 0; j < this->populationSize_; j++) {
        if (j == initialPointIndex_(i)) {
          if (i != 0) {
            initListValues_(j, i) = initListValues_(bestPointIndex_(i - 1), i - 1);
          }
        } else {
          initialPoint(i) = x0_(i, j);
          initListValues_(j, i) = this->optimisationProblem_->getObjectiveValue(initialPoint);
          this->numberOfIterations_++;
          if (initListValues_(j, i) < valueForInitialPoint) {
            valueForInitialPoint = initListValues_(j, i);
            bestPointIndex_(i) = j;
          }
        }
      }
      initialPoint(i) = x0_(i, bestPointIndex_(i));
    }

    //base vertex and opposite vertex init
    baseVertex_ = arma::Col<double>(numberOfDimensions);
    originalOppositeVertex_ = arma::Col<double>(numberOfDimensions);
    for (std::size_t i = 0; i < numberOfDimensions; i++) {
      baseVertex_(i) = x0_(i, initialPointIndex_(i));

      //if true, use u, else use v
      if (std::abs(baseVertex_(i) - boundaries_.col(0)(i)) > std::abs(baseVertex_(i) - boundaries_.col(1)(i))) {
        originalOppositeVertex_(i) = boundaries_.col(0)(i);
      } else {
        originalOppositeVertex_(i) = boundaries_.col(1)(i);
      }
    }
  }
}

