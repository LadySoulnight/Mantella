Contributing to Mantella
=======================

This guide will accompany you on your first contribution to Mantella, covering everything from setting up a development system to committing your changes.

In case you are already done and only want to submit a pull request, go directly to **Committing your changes** (at the end of the document).

**If you are in a hurry**, feel free to skip any part at your own account, but be aware that this might delay accepting your pull request (as someone needs to invest the time to finish it up :wink:), especially if the implementation is not yet working.

Let us know what you are planning
---------------------------------

If you found a bug in the source code, a mistake in any kind of documentation or you are missing some features within Mantella and want to implement/fix it yourself, please let us know in advance, so we can discuss how to implement the feature or handle the bug beforehand. This way, we can also give you early support and advices on your contribution.

To do this, simply add an issue to the [GitHub issue tracker](https://github.com/SebastianNiemann/Mantella/issues), describing what you plan to do and make clear whether you are already working on it. You can also contact us directly on [Gitter](https://gitter.im/SebastianNiemann/Mantella) at any point of your contribution.

In case you found a bug and want to fix it, please give us informations on what got wrong and how to reproduce it.

Forking Mantella
----------------

### Contributors

Your next step will be to fork Mantella on GitHub, for example by hitting `Fork` on the GitHub website and download your fork onto your local machine using the [Git tool](https://git-scm.com/downloads) of your choice.

### Team members

If you are a long-time contributor to Mantella and got write permissions for the repository, you don't need to fork Mantella to your account, but can directly add a new branch to Mantella 

``` bash
git checkout master
git branch YourUsername/YourAwesomeBranch
git checkout YourUsername/YourAwesomeBranch
```

Setting up a development system
-------------------------------

**The recommended and most easiest way** to set up a Mantella development system (including all dependencies), is to install [Vagrant](https://www.vagrantup.com/), clone Mantella onto your local machine, go to Mantella's root directory and run Vagrant.

```
git clone http://github.com/SebastianNiemann/Mantella.git
cd Mantella
vagrant up
```

**Done!**

This will install an Ubuntu virtual machine and set up all required dependencies, together with other useful tools for testing or debugging.

You can then connect to the Vagrant machine using your SSH client of choice (using `localhost:2222` as host:port and `vagrant` as username as well as password). The content of Mantella will then be accessible in the `/vagrant` folder on your virtual machine, being shared with the host system.

**Another way** is to manually run `./.setup.sh` on a local machine that you want to upgrade into a Mantella development system. Be aware that this script is written for Ubuntu 15.10 and may not work on other versions or operating systems. However, it also provides an overview about what is needed.

Coding guidelines
-----------------

**Most important:** Read some existing code, to get a better understanding of our code style :wink:

Section `Testing your work` covers tools and commands to automatically check some of the following guidelines.

### Adding new headers and sources

When adding new files, put your sources under `src/`, headers under `include/mantella_bits/` and tests under `test/`.

To include them into the library file and test binary, add your sources and tests to `CMakeLists.txt` and your headers into `include/mantella`.

By convention, we place all files directly into `src/`, `include/mantella_bits/` or `test/` and only add subfolders for base class (like `OptimisationProblem`), placing derivatives of such classes into these subfolders.

### Our code style and conventions

We usually follow the [Google style guide](https://code.google.com/p/google-styleguide/), with some exemptions/additions:

- **Never** break your code just because you reached some number of characters. Wrapping long code lines or comments should be done by your IDE, without changing the code.
- Avoid abbreviating variables and always write out their (meaning)full name.
- Put code in loops, if- or case-statements in `{ ... }`-blocks (even if its just one line).
- Use `#pragma once` instead of `#ifndef ...` as include guards.
- Group similar `#include`s (C++ STL, Armadillo, Mantella, ...) together.
- Use `mant::verify` if you want to check any user input and `assert` if the inputs are generated by another function or already verified.
- By conventions, we use `arma::uword` for all integer types (expects MPI forces us to use `int`) and `double` for all floating-point types.
- Always specify the whole template type (using `arma::Mat<double>` instead of `arma::Mat<>`) and avoid `typedef`'s (using `arma::Mat<double>` instead of `arma::mat`).
- [Include what you use](http://include-what-you-use.org/) (IWYU): For every symbol that you use in a source file, either the source or its header file should include a header that contains the declaration of that symbol.

### Writing tests

We use [Catch's BDD-style](https://github.com/philsquared/Catch/blob/master/docs/test-cases-and-sections.md) to write our tests, whereby `SCENARIO` is used to identify the (member) function to be tested and `GIVEN` to differentiate between multiple overloads of the same function.

The actual test cases are then organised by the `WHEN` (sometimes followed by `AND_WHEN`) and `THEN` (sometimes followed by `AND_THEN`) blocks and **cover positive tests, as well as exception tests**.

``` cpp
// Catch
#include <catch.hpp>
#include "catchExtension.hpp"

// Mantella
#include <mantella>

SCENARIO("myNewFunction", "[nameOfFile][myNewFunction]") {
  GIVEN("A number of elements and a precision value") {
    /* Tests for myNewFunction(arma::uword, double) goes here */
  }
  
  GIVEN("A number of elements") {
    /* Tests for myNewFunction(arma::uword) goes here */
  }
}
```

If you are adding tests for a whole class, each `SCENARIO` covers a single member function or class attribute and uses `nameOfClass.myNewFunction` instead of `myNewFunction`.

Subnamespaces (like `mant::bbob::`) are also added as prefix, resulting in `bbob::myNewFunction` instead of `myNewFunction`.

#### Choosing and logging test values

In most cases, the parameters of a function to be tested can either have any random value or need to fulfil a property (e.g. being positive or greater than other parameters), instead of being set to a specific number/value.

In such cases, use a randomly generated number to make the test input more fussy.

`/test/catchExtension.hpp` provides a lot random number generators for this purpose (`discreteRandomNumbers(...)`, `continuousRandomNumbers(...)`, ...). There are also helper functions to check complex conditions, like that two matrices are equal (`IS_EQUAL(...)`) or that the elements in a vector are uniformly drawn (`IS_UNIFORM(...)`).

To ease debugging failing tests, each value assignment should be [logged using Catch](https://github.com/philsquared/Catch/blob/master/docs/logging.md)'s `CAPTURE(...)` command.

### Adding inline comments

Describe complex parts of your code as well as [magic numbers](https://en.wikipedia.org/wiki/Magic_number_(programming)) as specific as possible and avoid vague descriptions.

**If you had to think a lot on how to implement something or needed to learn on [StackOverflow](http://stackoverflow.com/) or other site about how to do it, it is a complex part.**

However, if you find yourself documenting code that is hard to read or understand, you should consider to rewrite such tricky or unclear code. In general, you should strive for readable, maintainable code, by using well-known patterns and simple structures.

**Do not include doxygen or javadoc style comments**, these are regarded as user documents and placed into our [user docuemntation](http://mantella.info/api-overview/).

### Updating the user documentation

To update or extend the user documentation, you need to switch to the `gh-pages` branch at first, which contains the [Jekyll](https://jekyllrb.com/)-based source code for our website.

```
git checkout gh-pages
git pull
```

New functions can than be added by extending `_data/api.yml` and putting their description into `_includes/description.md`. Code example are placed into `_includes/examples/` an executed by running `.compile.sh`. This will automatically add the example's output into `_includes/examples/`.

**You shouldn't extend the changelog yourself**, issuing a new version and publishing the changelog will be done by one of the project owners.

Testing your work
-----------------

### Being in sync with the code style

You can check most code style rules and the IWYU rule by running the `./.code-checks.sh` script at Mantella's root directory. Use `./.code-checks.sh help` to get more information on additional options.

### Running tests

``` bash
mkdir build
cd build
rm -Rf CMakeCache.txt CMakeFiles/ cmake_install.cmake Makefile # Cleans up previous builds
cmake -DSUPPORT_MPI=On -DBUILD_TESTS=On -DMEASURE_CODE_COVERAGE=On ..
make
```

**In case you are building on a Windows machine**, you also want to add `-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=~` to the `cmake` command, as a symbolic link needs to be created during the `make` command, which is not supported on Windows hosts.

To execute your test, run

``` bash
../bin/mantellaTest ../test/data
```

Executing the tests can also be further configured by using [Catch's commandline options](https://github.com/philsquared/Catch/blob/master/docs/command-line.md), for example excluding tests that should fail

``` bash
../bin/mantellaTest ~[!shouldfail] ../test/data
```

or running just a subset of tests

``` bash
../bin/mantellaTest [myNewFunction] ../test/data
```

### Measuring the code coverage

Assuming you are still in the `build/` directory, you can measure the code coverage by running [lcov](http://ltp.sourceforge.net/coverage/lcov.php).

```
cd ./CMakeFiles/mantella.dir/src/
lcov --directory . --base-directory . --capture --output-file coverage.info
lcov --remove coverage.info '/usr/*' --output-file coverage.info
lcov --remove coverage.info '*.hpp' --output-file coverage.info
```

You can than either print out an overview on the code coverage of each file ...

```
lcov --list coverage.info
```

... or get details about the coverage within a file (in addition to the information above), by accessing the generated HTML code with your web browser.

```
genhtml coverage.info
```

**Be aware that reaching a 100% code coverage will most likely not result in a 100% functional coverage.** However, a less than 100% code coverage always guarantees a less than 100% functional coverage. 

### Validating the user documentation

To validated your changes to the user documentation, you need to switch to the `gh-pages` branch at first, which contains the [Jekyll](https://jekyllrb.com/)-based source code for our website.

```
git checkout gh-pages
git pull
```

This branch also contains a (specialised) `Vagrantfile`, setting up a development platform for the website, including Jekyll, website tests and everything to run our code examples.

```
vagrant up
```

You can than run a local web server, being accessible under `http://localhost:4000` ...

```
bundle exec jekyll serve --host 0.0.0.0
```

... or just generate the `_site` folder (which contains the actually delivered web site) to run the tests.

```
bundle exec jekyll build
```

Use `.compile.sh` to ensure that all code examples compile (you may want to revert the output files, otherwise you will commit a lot of changes) and `bundle exec htmlproofer ./_site --disable-external` to check for deadlinks.

Committing your changes
-----------------------

**If your fork or branch contains multiple commits**, please squash everything together into a single commit and provide a meaningful commit message (instead of simply aggregating all commit messages).

``` bash
git checkout master
git pull
git checkout MyAwesomeBranch
git rebase -i master
```

Commit messages should then be organised as followed:

``` text
<tag>: <subject>

<body>

<licence statement>
```

### Tag
Add one of the following tags, that describe your changes the best.

- `api`: Your change will break the current API in any way.
- `feature`: You added a new feature.
- `fix`: You fixed something.
- `test`: You changed a test.
- `documentation`: You changed the documentation.
- `refactor`:  You refactored some code.
- `maintenance`: For anything else.

### Subject
Add a description about the content of your commit.

### Body (optional)
In case the subject does not fully covers your changes, fell free to describe the details of your changes as specific as as you can/want. Do not be afraid to add multiple lines.

### Licence statement
End the commit message of your pull request adding a clear statement under which your licence your contribution is licensed.

Note that we cannot accept contributions that are either missing a licence statement or have chosen a licence incompatible to the MIT licence.

``` text
My contribution is licensed under the MIT license.
```

#### Team members

Team members are excluded from this, as one part of becoming a team member is to sign a statement already handling all future contributions.
